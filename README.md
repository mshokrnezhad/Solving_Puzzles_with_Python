# Solving Puzzles with Python

<div align="center">
  <img src="project_euler.png" alt="drawing" width="600"/>
</div>

This repository contains my solutions to various programming puzzles. These puzzles are designed to challenge your mathematical and programming skills, requiring creative problem-solving approaches to solve efficiently.

## About This Project

The purpose of this project is to:

1. Improve my problem-solving skills through diverse programming challenges.
2. Enhance my understanding of mathematics, algorithms, and data structures.
3. Practice and showcase Python programming techniques.
4. Build a collection of reusable algorithms and approaches for common computational problems.

## Structure

Each puzzle has its own directory named based on its source and number (e.g., `puzzle_XXX`). Inside each directory, you'll find:

- The puzzle definition
- The solution code
- A brief explanation of the approach (if required)
- Any additional resources or references used (if used)

## Progress

- [x] [Puzzle 001: Multiples of 3 or 5](#puzzle-001-multiples-of-3-or-5)
- [x] [Puzzle 002: Even Fibonacci Numbers](#puzzle-002-even-fibonacci-numbers)
- [x] [Puzzle 003: Largest Prime Factor](#puzzle-003-largest-prime-factor)
- [x] [Puzzle 004: Largest Palindrome Product](#puzzle-004-largest-palindrome-product)
- [x] [Puzzle 005: Smallest Multiple](#puzzle-005-smallest-multiple)
- [x] [Puzzle 006: Sum Square Difference](#puzzle-006-sum-square-difference)
- [x] [Puzzle 007: 10001st Prime](#puzzle-007-10001st-prime)
- [x] [Puzzle 008: Largest Product in a Series](#puzzle-008-largest-product-in-a-series)
- [x] [Puzzle 009: Special Pythagorean Triplet](#puzzle-009-special-pythagorean-triplet)
- [x] [Puzzle 010: Summation of Primes](#puzzle-010-summation-of-primes)
- [x] [Puzzle 011: Largest Product in a Grid](#puzzle-011-largest-product-in-a-grid)
- [ ] [Puzzle 012: Highly Divisible Triangular Number](#puzzle-012-highly-divisible-triangular-number)
- [x] [Puzzle 013: You Will All Conform](#puzzle-013-you-will-all-conform)

## Lessons Learned

### [Puzzle 001: Multiples of 3 or 5](puzzle_001)

- **Source:** [Project Euler's Problem 1](https://projecteuler.net/problem=1)
- **Puzzle Definition:**  
  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
- **Key lesson or insight gained:**  
  The puzzle introduces the concept of finding multiples and summing them. It's a good exercise in using modulo operations and conditional statements.
- **New concept or algorithm learned:**  
  While this puzzle doesn't require advanced algorithms, it reinforces the use of the modulo operator (`%`) to check for divisibility. It's a simple yet effective way to identify multiples.
- **Interesting optimization techniques:**
  1. We could optimize this solution by using the formula for the sum of an arithmetic sequence, reducing the time complexity from `O(n)` to `O(1)`.
  2. We could use a set to avoid double-counting numbers that are multiples of both 3 and 5 (like 15).

### [Puzzle 002: Even Fibonacci Numbers](puzzle_002)

- **Source:** [Project Euler's Problem 2](https://projecteuler.net/problem=2)
- **Puzzle Definition:**  
  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
- **Key lesson or insight gained:**  
  This puzzle introduces the Fibonacci sequence and emphasizes the importance of working with sequences and conditional summing. It also highlights the need to handle potentially large numbers efficiently.
- **New concept or algorithm learned:**  
  The puzzle demonstrates dynamic sequence generation, where each new term depends on the previous terms. It also introduces the concept of filtering elements in a sequence based on a condition (even numbers in this case).
- **Interesting optimization techniques used:**
  1. The solution uses a while loop to generate Fibonacci numbers only up to 4 million, avoiding unnecessary calculations.
  2. Instead of generating all Fibonacci numbers and then filtering, the solution checks for even numbers on-the-fly, which is more memory-efficient.
  3. The break condition in the while loop prevents the generation of numbers exceeding 4 million, optimizing the process.

### [Puzzle 003: Largest Prime Factor](puzzle_003)

- **Source:** [Project Euler's Problem 3](https://projecteuler.net/problem=3)
- **Puzzle Definition:**  
  The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143?
- **Key lesson or insight gained:**  
  This puzzle highlights the relationship between prime factorization and efficiency in number theory. It demonstrates that for large numbers, finding prime factors can be computationally intensive, emphasizing the need for optimized algorithms.
- **New concept or algorithm learned:**  
  The solution introduces a simple but effective method for prime factorization. It iteratively divides the target number by potential factors, reducing the puzzle size with each successful division. This approach is particularly useful for finding the largest prime factor without needing to calculate all prime factors.
- **Interesting optimization techniques used:**
  1. The algorithm stops when the remaining target becomes smaller than the current divisor, as this implies that the last successful divisor was the largest prime factor.
  2. The second approach (in [find_prime_numbers.py](puzzle_003/find_prime_numbers.py) uses a sieve-like method to generate prime numbers up to a certain limit, which can be more efficient for finding multiple prime factors.
  3. The use of `math.sqrt(i)` as an upper bound for checking divisibility in the second approach significantly reduces the number of iterations needed.

### [Puzzle 004: Largest Palindrome Product](puzzle_004)

- **Source:** [Project Euler's Problem 4](https://projecteuler.net/problem=4)
- **Puzzle Definition:**  
  A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99. Find the largest palindrome made from the product of two 3-digit numbers.
- **Key lesson or insight gained:**  
  This puzzle emphasizes the importance of considering both mathematical properties (palindromes) and algorithmic efficiency. It demonstrates how combining string manipulation with numerical calculations can lead to effective solutions for number theory problems.
- **New concept or algorithm learned:**  
  The solution introduces a reverse iteration approach, starting from the largest possible palindrome and working downwards. This method, combined with efficient factor checking, allows for quicker identification of the largest palindrome that meets the criteria.
- **Interesting optimization techniques used:**
  1. Using string manipulation to check for palindromes, which is more efficient than mathematical methods for this specific task.
  2. Starting from the upper bound and working downwards, which allows for early termination once a valid palindrome is found.
  3. Utilizing `math.ceil(math.sqrt(bound))` as a starting point for factor checking, which significantly reduces the search space.
  4. Employing a range check (`start < 1000 and start > 100`) to ensure factors are 3-digit numbers, efficiently filtering out invalid possibilities.

### [Puzzle 005: Smallest Multiple](puzzle_005)

- **Source:** [Project Euler's Problem 5](https://projecteuler.net/problem=5)
- **Puzzle Definition:**  
  2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
- **Key lesson or insight gained:**  
  This puzzle highlights the importance of understanding prime factorization and its role in finding the least common multiple (LCM) of a range of numbers. It demonstrates how breaking down numbers into their prime factors can lead to efficient solutions for seemingly complex numerical problems.
- **New concept or algorithm learned:**  
  The solution introduces a recursive approach to prime factorization, combined with a method to track the maximum count of each prime factor needed. This technique effectively calculates the LCM without directly computing multiples, which would be inefficient for larger ranges.
- **Interesting optimization techniques used:**
  1. Using a pre-defined list of prime numbers (`primal_nums`) to quickly identify prime factors, reducing unnecessary calculations.
  2. Employing a recursive function (`find_factors`) to efficiently break down composite numbers into their prime factors.
  3. Utilizing a numpy array to keep track of the maximum count of each prime factor across all numbers in the range, ensuring the smallest number that's divisible by all.
  4. Only updating the count when a higher power of a prime factor is encountered, optimizing space and avoiding redundant calculations.

### [Puzzle 006: Sum Square Difference](puzzle_006)

- **Source:** [Project Euler's Problem 6](https://projecteuler.net/problem=6)
- **Puzzle Definition:**  
  The sum of the squares of the first ten natural numbers is 385. The square of the sum of the first ten natural numbers is 3025. Hence the difference between the square of the sum and the sum of the squares is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
- **Key lesson or insight gained:**  
  This puzzle underscores the power of mathematical formulas in solving seemingly complex numerical problems. It demonstrates how understanding and applying mathematical series and summation formulas can lead to elegant and efficient solutions, avoiding brute-force calculations.
- **New concept or algorithm learned:**  
  The solution utilizes two key mathematical formulas:
  1. The sum of squares formula: $\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$
  2. The square of sum formula: $(\sum_{i=1}^n i)^2 = (\frac{n(n+1)}{2})^2$
     These formulas provide a direct way to calculate the required values without iterating through each number individually.
- **Interesting optimization techniques used:**
  1. Using closed-form mathematical expressions instead of loops, which drastically reduces computational complexity from `O(n)` to `O(1)`.
  2. Implementing the solution with just a few lines of code, demonstrating how mathematical insight can lead to concise and efficient programming.
  3. Avoiding the need for large data structures or memory-intensive operations by directly computing the final result.

### [Puzzle 007: 10001st Prime](puzzle_007)

- **Source:** [Project Euler's Problem 7](https://projecteuler.net/problem=7)
- **Puzzle Definition:**  
  By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10,001st prime number?
- **Key lesson or insight gained:**  
  This puzzle emphasizes the importance of efficient prime number generation and testing. It demonstrates that while finding prime numbers is a straightforward concept, implementing an efficient algorithm for large-scale prime number identification requires careful consideration of performance optimizations.
- **New concept or algorithm learned:**  
  The solution implements a simple but effective method for generating prime numbers sequentially. It uses the principle that a number is prime if it's not divisible by any prime number smaller than itself. This approach, known as trial division, is one of the fundamental methods for prime number testing.
- **Interesting optimization techniques used:**
  1. Maintaining a list of known prime numbers and only checking divisibility against these, rather than all numbers up to the candidate.
  2. Starting the search from 3 and incrementing by 2 each time, effectively skipping all even numbers after 2, which are known to be non-prime.
  3. Using an early exit strategy in the primality test function (`IsPrime`), which stops checking as soon as a divisor is found.

### [Puzzle 008: Largest Product in a Series](puzzle_008)

- **Source:** [Project Euler's Problem 8](https://projecteuler.net/problem=8)
- **Puzzle Definition:**  
  The four adjacent digits in the 1000-digit number that have the greatest product are 9 Ã— 9 Ã— 8 Ã— 9 = 5832. Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
- **Key lesson or insight gained:**  
  This puzzle demonstrates the importance of efficient string manipulation and numeric processing in handling large datasets. It emphasizes how a seemingly complex puzzle can be solved with a straightforward sliding window approach, highlighting the value of breaking down a large puzzle into smaller, manageable steps.
- **New concept or algorithm learned:**  
  The solution implements a sliding window technique to process the large number string. This approach involves moving a fixed-size window (in this case, 13 digits) across the string, calculating the product of digits within each window. This method is efficient for processing sequential data where you need to consider a fixed number of adjacent elements at a time.
- **Interesting optimization techniques used:**
  1. Converting the entire number to a string for easy digit-by-digit access, avoiding the need for complex numeric operations to extract individual digits.
  2. Using a single loop to iterate through the string, with a nested loop for the fixed-size window, which keeps the time complexity at `O(n)` where `n` is the length of the number string.
  3. Calculating the product incrementally within each window, rather than storing all possible 13-digit sequences and then calculating their products separately.
  4. Using an in-place comparison to update the maximum product, avoiding the need for additional data structures to store intermediate results.

### [Puzzle 009: Special Pythagorean Triplet](puzzle_009)

- **Source:** [Project Euler's Problem 9](https://projecteuler.net/problem=9)
- **Puzzle Definition:**  
  A Pythagorean triplet is a set of three natural numbers, a < b < c, for which aÂ² + bÂ² = cÂ². For example, 3Â² + 4Â² = 9 + 16 = 25 = 5Â². There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc.
- **Key lesson or insight gained:**  
  This puzzle underscores the importance of understanding mathematical relationships and constraints to optimize search spaces. It demonstrates how leveraging puzzle-specific knowledge (in this case, properties of Pythagorean triplets and the sum constraint) can significantly reduce the computational complexity of finding a solution.
- **New concept or algorithm learned:**  
  The solution employs a targeted search approach for Pythagorean triplets. Instead of blindly checking all possible combinations, it uses the constraints of the puzzle to narrow down the search range:
  1. Recognizing that $a < b < c$ and $a + b + c = 1000$.
  2. Deducing that a cannot exceed 332 (`ceil(1000/3) - 1`).
  3. Calculating an upper bound for `b` based on the remaining sum after choosing `a`.
- **Interesting optimization techniques used:**
  1. Setting an upper bound for `a` at 332, which significantly reduces the outer loop iterations.
  2. Dynamically calculating the upper bound for `b` in each iteration of the outer loop, further optimizing the search space.
  3. Using integer division and modulo operations to handle both even and odd cases for the `b_bound` calculation.
  4. Implicitly calculating `c` from the sum constraint rather than using a third loop, reducing the overall complexity.

### [Puzzle 010: Summation of Primes](puzzle_010)

- **Source:** [Project Euler's Problem 10](https://projecteuler.net/problem=10)
- **Puzzle Definition:**  
  The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.
- **Key lesson or insight gained:**  
  This puzzle highlights the importance of efficient prime number generation and summation for large ranges. It demonstrates that while brute-force approaches can work for smaller numbers, optimizing the algorithm becomes crucial when dealing with larger bounds. The solution also showcases the trade-offs between different implementation strategies and their impact on performance.
- **New concept or algorithm learned:**  
  The solution implements a modified Sieve of Eratosthenes approach:
  1. It maintains a growing list of prime numbers.
  2. For each new number, it checks divisibility only by primes up to its square root.
  3. It uses numpy arrays for efficient storage and operations on large sets of numbers.
- **Interesting optimization techniques used:**
  1. Using numpy arrays for fast numerical operations and efficient memory usage.
  2. Filtering the list of primes to check against by considering only primes up to the square root of the current number.
  3. Breaking the divisibility check early if any remainder is zero, avoiding unnecessary computations.
  4. Experimenting with different methods for checking primality, including vectorized operations (commented out) and a flag-based approach.
  5. Using `np.float64` data type to handle large sums accurately.

### [Puzzle 011: Largest Product in a Grid](puzzle_011)

- **Source:** [Project Euler's Problem 11](https://projecteuler.net/problem=11)
- **Puzzle Definition:**  
  In the 20Ã—20 grid, four numbers along a diagonal line have been marked. The product of these numbers is 26 Ã— 63 Ã— 78 Ã— 14 = 1788696. What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20Ã—20 grid?
- **Key lesson or insight gained:**  
  This puzzle demonstrates the importance of efficient grid traversal and handling edge cases in 2D array operations. It showcases how a seemingly complex puzzle can be solved with a systematic approach, checking all possible directions in a single pass through the grid.
- **New concept or algorithm learned:**  
  The solution implements a sliding window technique adapted for a 2D grid:
  1. It uses nested loops to iterate through each cell in the grid.
  2. For each cell, it calculates products in four directions: right, down, diagonal right, and diagonal left.
  3. It handles edge cases by setting products to 0 when calculations would go out of bounds.
- **Interesting optimization techniques used:**
  1. Using numpy for efficient array operations and memory management.
  2. Reading the grid from a file, allowing for easy modification of the input without changing the code.
  3. Calculating all four directional products in a single pass through the grid, reducing time complexity.
  4. Using conditional assignments to update the maximum product, avoiding repetitive if-else statements.
  5. Leveraging Python's ternary operator for concise max value updates (e.g., `maxProd = right if right > maxProd else maxProd`).

### [Puzzle 012: Highly Divisible Triangular Number](puzzle_012)

- **Source:** [Project Euler's Problem 12](https://projecteuler.net/problem=12)
- **Key lesson or insight gained:** In progress...
- **New concept or algorithm learned:** In progress...
- **Interesting optimization techniques used:** In progress...

### [Puzzle 013: You Will All Conform](puzzle_013)

- **Source:** [Puzzle 1 of Programming for the Puzzled](https://ocw.mit.edu/courses/6-s095-programming-for-the-puzzled-january-iap-2018/pages/puzzle-1-you-will-all-conform/)
- **Puzzle Definition:**  
  You Will All Conform involves a vector of F's and B's, representing forwards and backwards caps. The goal is to find the fewest commands needed to get either all F's or all B's, by flipping caps in specified intervals.
- **Key lesson or insight gained:**  
  This puzzle demonstrates the importance of identifying intervals of similar items in a sequence and making optimal decisions about which intervals to modify. It shows how proper grouping can lead to efficient solutions for sequence transformation problems.
- **New concept or algorithm learned:**  
  The solution introduces two approaches: a two-pass interval-based method and a one-pass method. Both approaches identify consecutive sections of similar items but handle them differently.

  The interval-based approach collects all intervals first, then decides which type to flip, while the one-pass approach makes decisions on-the-fly.

  Since the groups of forward and backward caps must alternate in the sequence, the number of groups for each type will either be equal or differ by one. So, if we observe the first cap in the queue and decide to flip all groups of the opposite type, we ensure that all caps become uniform with the fewest possible commands (what we do in the one-pass method).

- **Interesting optimization techniques used:**
  1. Using intervals to group consecutive items of the same type, reducing the number of operations.
  2. Appending a sentinel value ('END' or first element) to handle the last interval without special case code.
  3. The one-pass algorithm that avoids storing all intervals, making it more memory-efficient.
  4. Leveraging the alternating nature of cap groups to minimize commands - since forward and backward groups must alternate, flipping all groups of one type ensures uniformity with minimal operations.

---

## Thank You <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Hand%20gestures/Folded%20Hands.png" alt="Folded Hands" width="20" height="20" />

Thank you for exploring the Solving Puzzles with Python repository! I hope you find this collection helpful and inspiring as you dive into the world of problem solving. Feel free to fork the repo and make contributions. I will review them as soon as possible and your contributions will be merged into the main repo.
